{% extends "base.html" %}

{% block title %}Twistle - Daily Word Challenge{% endblock %}

{% block content %}
<!-- Progress Bar -->
<div class="w-full mb-6">
    <p class="text-sm font-medium mb-1 text-gray-900 dark:text-gray-200">Word {{ game.current_word_index + 1 }} of {{ game.total_words }}</p>
    <div class="h-2 w-full bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
        <div class="h-full bg-green-500" style="width: {{ ((game.current_word_index + 1) / game.total_words) * 100 }}%"></div>
    </div>
</div>

<!-- Game Board -->
<div class="bg-white dark:bg-gray-800 rounded-lg p-6 w-full mb-6 shadow-md">
    <!-- Timer and Attempts -->
    <div class="flex justify-between mb-6">
        <div class="flex items-center gap-2">
            <div class="flex items-center">
                <i id="timer-icon" class="fas fa-clock mr-2 text-gray-700 dark:text-gray-300"></i>
                <span id="timer" class="font-bold text-gray-900 dark:text-white">30s</span>
            </div>
            <button 
                id="boost-btn"
                type="button"
                class="opacity-0 pointer-events-none px-3 py-1 bg-blue-500 hover:bg-blue-600 text-white rounded-md text-sm flex items-center gap-1 transition-all duration-500"
                {{ 'disabled' if not game.time_boost_available }}
                title="Add {{ game.time_boost_amount }}s to timer"
            >
                <i class="fas fa-bolt"></i>
                <span>+{{ game.time_boost_amount }}s</span>
            </button>
        </div>
        <div class="text-gray-900 dark:text-gray-200">
            Attempt {{ game.attempt_number }}/3
        </div>
    </div>
    
    <!-- Word to Unscramble -->
    <div class="flex flex-col items-center mb-8">
        <p class="text-sm mb-2 text-gray-700 dark:text-gray-300">Unscramble this {{ game.word_length }}-letter word:</p>
        <div id="word-display" class="flex justify-center flex-wrap gap-1 my-3">
            {% for letter in game.jumbled_word %}
                <div class="letter-tile bg-gray-100 dark:bg-gray-700 w-12 h-12 flex items-center justify-center text-2xl font-bold rounded-md text-gray-900 dark:text-white cursor-pointer"
                     style="--rotation-angle: {{ range(0, 4)|random * 90 }}deg">{{ letter|upper }}</div>
            {% endfor %}
        </div>
    </div>
    
    <!-- Input Form -->
    <form id="guess-form" class="mb-4">
        <div class="flex w-full">
            <input
                type="text"
                id="guess-input"
                class="flex-1 min-w-0 px-4 py-3 rounded-l-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                placeholder="Type your answer..."
                maxlength="{{ game.word_length }}"
                autocomplete="off"
                autocapitalize="off"
                spellcheck="false"
            >
            <button 
                id="shuffle-btn"
                type="button"
                class="px-4 py-3 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 border-y border-gray-200 dark:border-gray-700 text-gray-700 dark:text-white whitespace-nowrap"
                title="Shuffle letters"
            >
                <i class="fas fa-random"></i>
                <span id="shuffle-count" class="ml-1">2</span>
            </button>
            <button 
                type="submit" 
                class="bg-indigo-600 hover:bg-indigo-700 text-white px-6 py-3 rounded-r-lg font-medium"
            >
                Submit
            </button>
        </div>
    </form>
    
    <!-- Hint Section -->
    <div id="hint-section" class="text-center {{ 'hidden' if not game.hint_revealed else '' }}">
        <p class="text-sm italic text-gray-700 dark:text-gray-300">
            Hint: {{ game.word_hints[game.current_word_index] }}
        </p>
    </div>
</div>

<!-- Score Information -->
<div class="bg-white dark:bg-gray-800 rounded-lg p-4 w-full mb-4 shadow-md">
    <div class="flex justify-between">
        <div>
            <p class="text-sm text-gray-700 dark:text-gray-300">Current Score</p>
            <p id="current-score" class="text-xl font-bold text-gray-900 dark:text-white">{{ game.score }}</p>
        </div>
        {# <div>
            <p class="text-sm text-gray-700 dark:text-gray-300">Today's Theme</p>
            <p class="text-xl font-bold text-gray-900 dark:text-white">{{ game.theme }}</p>
        </div> #}
        <div>
            <p class="text-sm text-gray-700 dark:text-gray-300">Words Solved</p>
            <p id="words-solved" class="text-xl font-bold text-gray-900 dark:text-white">{{ game.words_solved }}/{{ game.total_words }}</p>
        </div>
    </div>
</div>

<!-- Word Result Modal Template (hidden) -->
<template id="word-result-template">
    <div class="text-center">
        <h2 class="text-xl font-bold mb-2 text-gray-900 dark:text-white">Word <span id="result-word-number"></span></h2>
        
        <div id="result-word-display" class="flex justify-center mb-4"></div>
        
        <p id="result-message" class="text-gray-900 dark:text-gray-200 mb-4"></p>
        
        <div id="points-earned-section" class="mb-4 p-2 bg-green-100 dark:bg-green-900 rounded-lg">
            <p class="text-green-700 dark:text-green-300">Points earned: <span id="points-earned">0</span></p>
        </div>
        
        <div class="flex gap-2">
            <form id="next-action-form" method="POST" class="w-full">
                <input type="hidden" name="action" id="action-input" value="">
                <button type="submit" id="next-word-btn" class="w-full py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-full font-bold">
                    Next Word
                </button>
            </form>
        </div>
    </div>
</template>

<!-- Feedback popup container -->
<div id="feedback-popup" class="fixed inset-0 flex items-center justify-center pointer-events-none z-40 opacity-0 transition-opacity duration-300">
    <div id="feedback-message" class="px-6 py-3 rounded-lg text-white text-lg font-bold"></div>
</div>

{% if config.debug_mode %}
    <!-- Debug Controls -->
    <div class="fixed bottom-4 right-4 bg-red-100 dark:bg-red-900 p-4 rounded-lg shadow-lg border-2 border-red-500">
        <h3 class="text-red-700 dark:text-red-300 font-bold mb-2">Debug Controls</h3>
        <form action="/reset_game" method="POST" class="flex gap-2">
            <button type="submit" 
                    class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-md text-sm font-medium flex items-center gap-1">
                <i class="fas fa-redo"></i>
                Reset Game
            </button>
        </form>
    </div>
{% endif %}
{% endblock %}

{% block extra_js %}
<script>
    // Game variables
    let timeRemaining = 30;
    let timerInterval;
    let hintShown = {{ 'true' if game.hint_revealed else 'false' }};
    let lastServerSync = Date.now();
    let serverTimeDiff = 0;
    let shufflesRemaining = {{ game.shuffles_remaining }};
    let bonusTime = {{ game.bonus_time }};
    let timeBoostAvailable = {{ 'true' if game.time_boost_available else 'false' }};
    
    // DOM Elements
    const timerDisplay = document.getElementById('timer');
    const timerIcon = document.getElementById('timer-icon');
    const guessForm = document.getElementById('guess-form');
    const guessInput = document.getElementById('guess-input');
    const hintSection = document.getElementById('hint-section');
    const wordDisplay = document.getElementById('word-display');
    const currentScoreDisplay = document.getElementById('current-score');
    const wordsSolvedDisplay = document.getElementById('words-solved');
    const feedbackPopup = document.getElementById('feedback-popup');
    const feedbackMessage = document.getElementById('feedback-message');
    const boostBtn = document.getElementById('boost-btn');
    
    // Initialize game
    function initGame() {
        guessInput.focus();
        
        // Check if hint should be shown
        if (hintShown) {
            hintSection.classList.remove('hidden');
        }
    }
    
    // Timer functionality
    function startTimer() {
        clearInterval(timerInterval);
        syncWithServer();
        
        timerInterval = setInterval(() => {
            // Sync with server every 5 seconds
            if (Date.now() - lastServerSync > 5000) {
                syncWithServer();
            }
            
            timeRemaining = Math.max(0, timeRemaining - 1);
            updateTimerDisplay();
            
            if (timeRemaining <= 0) {
                clearInterval(timerInterval);
                handleTimeUp();
            }
        }, 1000);
    }
    
    function syncWithServer() {
        fetch('/sync_timer', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            timeRemaining = data.time_remaining;
            serverTimeDiff = Date.now() - (data.server_time * 1000);
            lastServerSync = Date.now();
            updateTimerDisplay();
            
            if (timeRemaining <= 0) {
                clearInterval(timerInterval);
                handleTimeUp();
            }
        })
        .catch(error => console.error('Error syncing timer:', error));
    }
    
    function updateTimerDisplay() {
        timerDisplay.textContent = `${timeRemaining}s`;
        
        if (timeRemaining <= 10) {
            timerDisplay.classList.add('text-red-500');
            timerIcon.classList.add('text-red-500');
            
            // Automatically reveal hint at 10 seconds
            if (!hintShown) {
                hintSection.classList.remove('hidden');
            }
            
            // Show boost button if available
            if (timeBoostAvailable) {
                boostBtn.classList.remove('opacity-0', 'pointer-events-none');
            }
        } else {
            timerDisplay.classList.remove('text-red-500');
            timerIcon.classList.remove('text-red-500');
            
            // Hide boost button if not in danger zone
            if (timeBoostAvailable) {
                boostBtn.classList.add('opacity-0', 'pointer-events-none');
            }
        }
    }

    function checkTimerWithServer() {
        fetch('/check_timer')
            .then(response => response.json())
            .then(data => {
                // If server says time is up but our timer hasn't caught up
                if (data.time_up && timeRemaining > 0) {
                    timeRemaining = 0;
                    updateTimerDisplay();
                    clearInterval(timerInterval);
                    handleTimeUp();
                }
                
                // Show hint if available
                if (data.hint_available && !hintShown) {
                    hintShown = true;
                    hintSection.innerHTML = `<p class="text-sm italic text-gray-700 dark:text-gray-300">Hint: ${data.hint}</p>`;
                    hintSection.classList.remove('hidden');
                }
            })
            .catch(error => console.error('Error checking timer:', error));
    }
    
    function handleTimeUp() {
        fetch('/check_timer')
            .then(response => response.json())
            .then(data => {
                if (data.time_up) {
                    showWordResult({
                        is_correct: false,
                        correct_word: data.correct_word,
                        time_remaining: 0,
                        out_of_time: true
                    });
                }
            })
            .catch(error => console.error('Error handling time up:', error));
    }
    
    // Guess handling
    function submitGuess(event) {
        event.preventDefault();
        
        const guess = guessInput.value.trim();
        if (!guess) return;
        
        // Reset tile states when submitting
        resetTileStates();
        
        // Disable form during check
        guessInput.disabled = true;
        guessForm.querySelector('button').disabled = true;
        
        fetch('/check_guess', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ guess })
        })
        .then(response => response.json())
        .then(data => {
            if (data.already_used) {
                showFeedback(false, false, 0, true);
                // Re-enable form after showing feedback
                guessInput.value = '';
                guessInput.disabled = false;
                guessForm.querySelector('button').disabled = false;
                guessInput.focus();
            } else if (data.is_anagram && !data.is_correct) {
                showFeedback(false, true, data.points_earned || GAME_CONFIG.anagram_bonus);
                currentScoreDisplay.textContent = data.new_score;
                guessInput.value = '';
                guessInput.disabled = false;
                guessForm.querySelector('button').disabled = false;
                guessInput.focus();
            } else {
                showFeedback(data.is_correct);
                setTimeout(() => {
                    showWordResult(data);
                }, 1000);
            }

            // Show hint if returned from server
            if (data.show_hint && !hintShown) {
                hintShown = true;
                hintSection.innerHTML = `<p class="text-sm italic text-gray-700 dark:text-gray-300">Hint: ${data.hint}</p>`;
                hintSection.classList.remove('hidden');
            }
        })
        .catch(error => {
            console.error('Error checking guess:', error);
            guessInput.disabled = false;
            guessForm.querySelector('button').disabled = false;
        });
    }

    function showFeedback(isCorrect, isAnagram = false, anagramPoints = 0, alreadyUsed = false, isBoost = false) {
        if (isBoost) {
            feedbackMessage.innerHTML = `
                <div class="text-lg">Time Boost!</div>
                <div class="text-sm">+{{ game.time_boost_amount }}s added</div>
            `;
            feedbackMessage.className = 'px-6 py-3 rounded-lg text-white text-lg font-bold bg-blue-500';
        } else if (alreadyUsed) {
            feedbackMessage.innerHTML = `
                <div class="text-lg">Already Found!</div>
                <div class="text-sm">This anagram was already used</div>
            `;
            feedbackMessage.className = 'px-6 py-3 rounded-lg text-white text-lg font-bold bg-gray-500';
        } else if (isAnagram) {
            feedbackMessage.innerHTML = `
                <div class="text-2xl mb-1">BONUS!</div>
                <div>Valid Anagram Found!</div>
                <div class="text-sm">+${anagramPoints} points</div>
                <div class="text-sm">+${bonusTime}s time bonus</div>
            `;
            feedbackMessage.className = 'px-6 py-3 rounded-lg text-white text-lg font-bold bg-amber-500';
        } else {
            feedbackMessage.textContent = isCorrect ? 'Correct!' : 'Try again!';
            feedbackMessage.className = `px-6 py-3 rounded-lg text-white text-lg font-bold ${isCorrect ? 'bg-green-500' : 'bg-red-500'}`;
        }
        
        // Show feedback
        feedbackPopup.classList.remove('opacity-0');
        
        // Hide after appropriate duration
        setTimeout(() => {
            feedbackPopup.classList.add('opacity-0');
        }, alreadyUsed ? 1500 : (isAnagram ? 2000 : 1000));
    }
    
    function showWordResult(data) {
        // Clear timer if moving to next word, out of attempts, or out of time
        if (data.is_correct || data.out_of_attempts || data.out_of_time) {
            clearInterval(timerInterval);
            timerInterval = null;
        }

        const template = document.getElementById('word-result-template');
        const content = template.content.cloneNode(true);

        // Fill in word information
        content.getElementById('result-word-number').textContent = '{{ game.current_word_index + 1 }}';

        const wordDisplay = content.getElementById('result-word-display');
        if (data.out_of_attempts || data.out_of_time) {
            for (let i = 0; i < data.correct_word.length; i++) {
                const letterTile = document.createElement('div');
                letterTile.className = 'flex items-center justify-center w-8 h-8 bg-green-500 rounded text-white font-bold text-sm';
                letterTile.textContent = data.correct_word[i].toUpperCase();
                wordDisplay.appendChild(letterTile);
            }
        } else {
            wordDisplay.classList.add('hidden');
        }

        // Set message based on result
        if (data.is_correct) {
            content.getElementById('result-message').textContent = 
                `Solved in attempt {{ game.attempt_number }}!`;
            content.getElementById('points-earned').textContent = data.points_earned;
            currentScoreDisplay.textContent = data.new_score;
        } else if (data.out_of_attempts) {
            content.getElementById('result-message').textContent = 
                "That was your last attempt. Let's move on to the next word.";
            content.getElementById('points-earned-section').classList.add('hidden');
        } else if (data.out_of_time) {
            content.getElementById('result-message').textContent = 
                "Time's up! Better luck on the next word.";
            content.getElementById('points-earned-section').classList.add('hidden');
        } else {
            content.getElementById('result-message').textContent = 
                "Incorrect! Try again.";
            content.getElementById('points-earned-section').classList.add('hidden');
        }

        // Handle button text and functionality
        const nextWordBtn = content.getElementById('next-word-btn');
        const actionForm = content.getElementById('next-action-form');
        const actionInput = content.getElementById('action-input');

        if (data.is_correct || data.out_of_attempts || data.out_of_time) {
            nextWordBtn.textContent = "Next Word";
            actionForm.action = "/next_word";
            actionInput.value = "next";
        } else {
            nextWordBtn.textContent = "Try Again";
            actionForm.action = "/check_guess";
            actionInput.value = "retry";
        }

        // Add keyboard support for modal buttons
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && document.getElementById('modal-container')) {
                e.preventDefault();
                actionForm.submit();
            }
        });

        // Show modal
        showModal(content);
    }
    
    function showModal(content) {
        const modalContainer = document.createElement('div');
        modalContainer.id = 'modal-container';
        modalContainer.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';
        modalContainer.appendChild(content);

        document.body.appendChild(modalContainer);
    }

    function hideModal() {
        const modalContainer = document.getElementById('modal-container');
        if (modalContainer) {
            modalContainer.remove();
        }
        // Ensure feedback popup is also hidden
        feedbackPopup.classList.add('opacity-0');
    }
    
    // Letter tile click handling for easier input
    function handleLetterTileClick(event) {
        if (event.target.classList.contains('letter-tile')) {
            const tile = event.target;
            const letter = tile.textContent.trim().toLowerCase();
            
            if (tile.classList.contains('used')) {
                // Remove the letter from the input
                const currentValue = guessInput.value;
                const letterIndex = currentValue.indexOf(letter);
                if (letterIndex !== -1) {
                    guessInput.value = currentValue.slice(0, letterIndex) + 
                                     currentValue.slice(letterIndex + 1);
                }
                tile.classList.remove('used');
            } else {
                guessInput.value += letter;
                tile.classList.add('used');
            }
            
            guessInput.focus();
        }
    }

    // Add a function to reset tile states
    function resetTileStates() {
        const tiles = document.querySelectorAll('.letter-tile');
        tiles.forEach(tile => tile.classList.remove('used'));
    }
    
    // Shuffle functionality
    function shuffleLetters() {
        if (shufflesRemaining <= 0) return;
        
        const shuffleBtn = document.getElementById('shuffle-btn');
        shuffleBtn.disabled = true;
        
        fetch('/shuffle_word', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const wordDisplay = document.getElementById('word-display');
                
                // Remove old tiles with fade out
                const oldTiles = wordDisplay.children;
                Array.from(oldTiles).forEach(tile => {
                    tile.style.transition = 'opacity 0.2s';
                    tile.style.opacity = '0';
                });
                
                // Add new tiles after brief delay
                setTimeout(() => {
                    wordDisplay.innerHTML = '';
                    
                    // Create new letter tiles with the shuffled word
                    for (let letter of data.shuffled_word) {
                        const tile = document.createElement('div');
                        tile.className = 'letter-tile bg-gray-100 dark:bg-gray-700 w-12 h-12 flex items-center justify-center text-2xl font-bold rounded-md text-gray-900 dark:text-white cursor-pointer';
                        tile.style.setProperty('--rotation-angle', `${Math.floor(Math.random() * 4) * 90}deg`);
                        tile.textContent = letter.toUpperCase().trim();
                        wordDisplay.appendChild(tile);
                    }
                    
                    // Reset the input field when shuffling
                    guessInput.value = '';
                }, 200);
                
                shufflesRemaining = data.shuffles_remaining;
                updateShuffleButton();
            }
        })
        .catch(error => {
            console.error('Error shuffling word:', error);
        })
        .finally(() => {
            shuffleBtn.disabled = false;
        });
    }
    
    function updateShuffleButton() {
        const shuffleBtn = document.getElementById('shuffle-btn');
        const shuffleCount = document.getElementById('shuffle-count');
        
        shuffleCount.textContent = shufflesRemaining;
        
        if (shufflesRemaining <= 0) {
            shuffleBtn.classList.add('opacity-50', 'cursor-not-allowed');
            shuffleBtn.disabled = true;
        }
    }
    
    // Time boost functionality
    function handleTimeBoost() {
        if (!timeBoostAvailable) return;
        
        boostBtn.disabled = true;
        
        fetch('/boost_time', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                timeBoostAvailable = false;
                timeRemaining += data.boost_amount;
                updateTimerDisplay();
                
                // Remove the boost button completely
                boostBtn.remove();
                
                // Show boost feedback
                showFeedback(true, false, 0, false, true);
            }
        })
        .catch(error => {
            console.error('Error using time boost:', error);
            boostBtn.disabled = false;
        });
    }
    
    // Next word handling
    function loadNextWord() {
        // Remove redundant timer clearing here since it's handled in showWordResult
        const actionForm = document.getElementById('next-action-form');
        actionForm.submit();
    }

    // Event Listeners
    document.addEventListener('DOMContentLoaded', () => {
        initGame();
        startTimer(); // Initial timer start
        
        guessForm.addEventListener('submit', submitGuess);
        
        wordDisplay.addEventListener('click', handleLetterTileClick);
        
        const shuffleBtn = document.getElementById('shuffle-btn');
        shuffleBtn.addEventListener('click', shuffleLetters);
        updateShuffleButton();
        
        boostBtn.addEventListener('click', handleTimeBoost);

        guessInput.addEventListener('input', (e) => {
            const currentValue = e.target.value.toLowerCase();
            const tiles = document.querySelectorAll('.letter-tile');
            
            // Reset all tiles
            resetTileStates();
            
            // Create a pool of available tiles
            const availableTiles = Array.from(tiles);
            
            // Mark tiles as used based on current input
            for (let i = 0; i < currentValue.length; i++) {
                const letter = currentValue[i];
                const tileIndex = availableTiles.findIndex(tile => 
                    !tile.classList.contains('used') && 
                    tile.textContent.toLowerCase() === letter
                );
                
                if (tileIndex !== -1) {
                    availableTiles[tileIndex].classList.add('used');
                    availableTiles.splice(tileIndex, 1); // Remove used tile from pool
                }
            }
        });
    });
</script>

<style>
    @keyframes twistAndOffset {
        from { transform: rotate(0deg) translateY(0); }
        to { transform: rotate(var(--rotation-angle)) translateY(var(--y-offset)); }
    }
    
    .letter-tile {
        animation: twistAndOffset 0.5s ease-out forwards;
        --rotation-angle: 0deg;
        --y-offset: 0px;
        transition: background-color 0.2s, color 0.2s;
    }
    
    .letter-tile.used {
        background-color: rgb(147 197 253); /* bg-blue-300 */
        color: rgb(30 58 138); /* text-blue-900 */
        cursor: pointer;
    }
    
    .dark .letter-tile.used {
        background-color: rgb(30 58 138); /* dark:bg-blue-900 */
        color: rgb(147 197 253); /* dark:text-blue-300 */
    }
</style>
{% endblock %}